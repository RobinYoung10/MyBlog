---
title: 数据库事务
date: 2019-04-30 14:00:35
tags: 事务
---

一个运行良好的事务处理系统，必须包含ACID特征，ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。

* **原子性**：一个事务必须被视作一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作。
* **一致性**：数据库总是从一个一致性的状态转换到另一个一致性的状态。在执行事务时，就算里面某一个操作系统崩溃，也不会损失数据，因为事务最终没有提交，所以事务中所作的修改不会保存到数据库中。
* **隔离性**：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
* **持久性**：一旦事务提交，其所做的修改就会永久保存到数据库中。

### 并发一致性问题

##### 1.更新丢失

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

##### 2.脏读

事务B读取到事务A已修改未提交的数据，如果事务A撤销了这次修改，则事务B读取到的数据就是脏数据。

##### 3.不可重复读

在一个事务内，多次读取同一个数据，在这个事务还没有结束时，另一个事务也访问同一个数据并修改提交，那么第一个事务的两次读到数据不一样。

##### 4.幻读

一个事务A按相同的查询条件多次读取数据，却发现事务B插入了满足其查询条件的新数据，这种现象就是幻读。（和可重复读类似，但是幻读是插入和删除，而不可重复读是修改数据）

### 隔离级别

##### READ UNCOMMITTED（未提交读）

在此级别中，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，也就是**脏读**（Dirty Read）。这个级别会导致很多问题，在实际应用中很少使用。

##### READ COMMITTED（提交读）

大多数数据库系统的默认隔离级别。在此级别中，一个事务开始时，只能看见已经提交的事务所做的修改，这个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫不可重复读，两次执行同样的查询，可能会得到不一样的结果，因为事务读取的时候获得读锁，但是读完后立刻释放，不需要等待事务结束，而写锁则是事务提交后才释放。

##### REPEATABLE READ（可重复读）

此隔离级别解决了脏读和不可重复读的问题，所有被读的数据都不能改变。但是无法解决幻读问题。可重复读是MySQL的默认事务隔离级别。

##### SERIALIZABLE（可串行化）

最高隔离级别。他通过强制事务串行执行，所有事务一个接着一个执行，解决了幻读问题。简单来说，会在读取的每一行数据都加锁，可能会导致大量的超时和锁争用问题。

隔离级别|脏读|不可重复读|幻读
---|---|---|---
未提交读|√|√|√
提交读|×|√|√
可重复读|×|×|√
可串行化|×|×|×